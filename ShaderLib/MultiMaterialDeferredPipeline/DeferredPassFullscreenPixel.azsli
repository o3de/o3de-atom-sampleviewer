/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#include <viewsrg_all.srgi>
#include <scenesrg_all.srgi>

#include <Atom/Features/PostProcessing/FullscreenVertex.azsli>
#include <Atom/Features/ScreenSpace/ScreenSpaceUtil.azsli>

#if PIPELINE_HAS_DRAW_SRG
#error "Deferred materials can't have a custom DrawSrg"
#endif

#if PIPELINE_HAS_OBJECT_SRG
#error "Deferred materials can't have a custom ObjectSrg"
#endif

#include <Atom/Features/Pipeline/Deferred/DeferredPassDrawSrg.azsli>

// we have the same render-targets as a forward pass
#include <Atom/Features/Pipeline/Forward/ForwardPassOutput.azsli>

#include <Atom/Features/Pipeline/Deferred/VisibilityBuffer.azsli>
#include <Atom/Features/MeshInfo/MeshInfo.azsli>
#include <Atom/Features/MeshInfo/MeshInfoUtil.azsli>

bool GetDrawPacketId(int index, inout int drawPacketId)
{
    uint numStructs;
    uint stride;

    DrawSrg::m_drawPacketIds.GetDimensions(numStructs, stride);

    if (index < 0 || index >= numStructs)
    {
        return false;
    }
    drawPacketId = DrawSrg::m_drawPacketIds[index];
    return true;
}

ForwardPassOutput MainPS(VSOutput IN, in uint sampleIndex : SV_SampleIndex)
{
    uint2 screenCoords = uint2(IN.m_position.xy);

    // ------- Output -------
    ForwardPassOutput OUT;

    // ------- Unpack Visibility Buffers -------

    VisibilityBuffer vbuffer;
    MeshInfo meshInfo;
    vbuffer.m_triangleId = 0;
    bool renderPixel = false;
    if (unpackVisibilityBuffer(PassSrg::m_visibilityBuffer_0[screenCoords], PassSrg::m_visibilityBuffer_1[screenCoords], vbuffer))
    {
        renderPixel = true;
        int drawPacketId;
        renderPixel &= GetDrawPacketId(vbuffer.m_meshInfoIndex, drawPacketId);
        renderPixel &= (drawPacketId == DrawSrg::m_shaderDrawPacketId);
        renderPixel &= GetMeshInfoEntry(vbuffer.m_meshInfoIndex, meshInfo);
        renderPixel &= (meshInfo.m_indexBufferIndex >= 0);
        renderPixel &= (meshInfo.m_materialTypeId >= 0);
    }

    if (renderPixel)
    {        
        VsInput dIN;
        LoadInterpolatedVertexData(meshInfo, vbuffer.m_triangleId, vbuffer.m_barycentrics, dIN);

        // ------- System Values -------

        VsSystemValues SV;
        SV.m_transformMatrixIndex = meshInfo.m_objectIdForTransform;
        SV.m_materialTypeId = meshInfo.m_materialTypeId;
        SV.m_materialInstanceId = meshInfo.m_materialInstanceId;
        SV.m_lightingChannels = meshInfo.m_lightingChannels;

        // ------- Material Parameters -------
        const MaterialParameters params = GetMaterialParameters(SV.m_materialTypeId, SV.m_materialInstanceId);

        // ------- Vertex Stage -------    

        VsOutput dOUT = EvaluateVertexGeometry(dIN, SV, params);
        dOUT.position.xyz /= dOUT.position.w;

        // ------- Geometry -> Surface -> Lighting -------

        PixelGeometryData geoData = EvaluatePixelGeometry(dOUT, SV, vbuffer.m_isFrontFace, params);

        Surface surface = EvaluateSurface(dOUT, SV, geoData, params);

        LightingData lightingData = EvaluateLighting(surface, IN.m_position, ViewSrg::m_worldPosition.xyz);

        // --- Diffuse Lighting ---

        OUT.m_diffuseColor.rgb = lightingData.diffuseLighting;
        OUT.m_diffuseColor.a = -1;  // Disable Subsurface Scattering

            // --- Specular Lighting ---

        OUT.m_specularColor.rgb = lightingData.specularLighting.rgb;
        OUT.m_specularColor.a = 1.0;

        OUT.m_specularColor.rgb = vbuffer.m_barycentrics;

        // --- Roughness and Specular ---

        OUT.m_specularF0.rgb = surface.GetSpecularF0();
        OUT.m_specularF0.a = surface.roughnessLinear;

        // --- Albedo ---

        OUT.m_albedo.rgb = surface.albedo * lightingData.diffuseResponse * lightingData.diffuseAmbientOcclusion;
        OUT.m_albedo.a = lightingData.specularOcclusion;


        // --- Normal ---
    
        OUT.m_normal.rgb = EncodeNormalSignedOctahedron(surface.GetDefaultNormal());
        OUT.m_normal.a = EncodeUnorm2BitFlags(o_enableIBL, o_specularF0_enableMultiScatterCompensation);
    }
    else {
        OUT.m_diffuseColor = float4(1, 1, 1, 1);
        OUT.m_specularColor = float4(1, 1, 1,1);
        OUT.m_specularF0 = float4(1, 1,1,1);
        OUT.m_albedo = float4(1, 1,1,1);

        OUT.m_normal.rgb = EncodeNormalSignedOctahedron(float3(0, 0, 1));
        OUT.m_normal.a = EncodeUnorm2BitFlags(o_enableIBL, o_specularF0_enableMultiScatterCompensation);
    }
    if (renderPixel == false)
    {
        // Note: we need this if/else - construct to make sure we never access a bindless buffer with an illegal index, since that crashes the shader
        // even if we call discard for the fragment, since that doesn't neccesarily fully deactivate the shader, it only prevents writing to the output. 
        discard;
    }
    return OUT;
}
